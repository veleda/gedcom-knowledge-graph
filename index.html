<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>GEDCOM Knowledge Graph</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>

/* --- Page Layout --- */
body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  margin: 0;
  padding: 20px;
  background: #f7f9fc;
  color: #333;
}

h1 {
  text-align: center;
  color: #2c3e50;
  margin-bottom: 20px;
}

/* --- File Input and Buttons --- */
#gedcomFile {
  display: inline-block;
  margin-right: 10px;
  padding: 6px;
  border-radius: 4px;
  border: 1px solid #ccc;
}

button {
  padding: 6px 14px;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

button:hover {
  background-color: #2980b9;
}

#downloadLink {
  display: inline-block;
  margin-left: 10px;
  padding: 6px 14px;
  background-color: #2ecc71;
  color: white;
  text-decoration: none;
  border-radius: 4px;
  font-size: 14px;
  transition: background 0.2s;
}

#downloadLink:hover {
  background-color: #27ae60;
}

/* --- Count Info --- */
#count {
  margin-top: 10px;
  font-weight: 500;
  color: #555;
}

/* --- SVG Graph --- */
svg {
  border: 1px solid #ccc;
  background-color: #fff;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  border-radius: 6px;
  display: block;
  margin: 20px auto;
}

/* Node Styles */
.node circle {
  stroke: #333;
  stroke-width: 1.5px;
  cursor: pointer;
  transition: fill 0.2s, r 0.2s;
}

.node.person circle {
  fill: #3498db;
}

.node.family circle {
  fill: #e67e22;
}

.node:hover circle {
  stroke-width: 2.5px;
  r: 12px;
}

/* Links */
.link {
  stroke: #999;
  stroke-opacity: 0.6;
}

/* Labels */
text {
  font: 12px sans-serif;
  pointer-events: none;
  fill: #2c3e50;
  font-weight: 500;
}

 .tooltip {
    position: absolute;
    pointer-events: none;
    background: rgba(0,0,0,0.8);
    color: #fff;
    padding: 6px 8px;
    border-radius: 4px;
    font-size: 12px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    transform: translate(-50%, -120%); /* show above cursor */
    white-space: nowrap;
    z-index: 1000;
    display: none;
  }
  .zoom-rect {
    cursor: move;
    fill: none;
    pointer-events: all;
  }
/* Optional: Smooth transition for hover effect on nodes */
.node text {
  transition: fill 0.2s;
}


  </style>

</head>
<body>
  <h1>GEDCOM Knowledge Graph</h1>

  <div id="controls">
    <input type="file" id="gedcomFile">
    <button id="uploadBtn">Upload GEDCOM</button>
    <span id="status" style="margin-left:12px"></span>
    <div id="count"></div>
    <a id="dl" style="display:none">Download TTL</a>
  </div>

  <svg id="graph" width="1000" height="600"></svg>

  <script>
    const BACKEND_URL = "https://gedcom-knowledge-graph-backend.onrender.com";

    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("gedcomFile");
    const status = document.getElementById("status");
    const countDiv = document.getElementById("count");
    const dl = document.getElementById("dl");
    const svg = d3.select("#graph");

    uploadBtn.addEventListener("click", uploadGedcom);

    async function uploadGedcom() {
      status.textContent = "";
      if (!fileInput.files.length) {
        alert("Please choose a GEDCOM file first.");
        return;
      }
      const file = fileInput.files[0];
      const fd = new FormData();
      fd.append("file", file);

      try {
        status.textContent = "Uploading...";
        const resp = await fetch(`${BACKEND_URL}/parse`, { method: "POST", body: fd });

        if (!resp.ok) {
          const txt = await resp.text();
          alert("Upload failed: " + txt);
          status.textContent = "";
          return;
        }

        const data = await resp.json();
        status.textContent = "Done.";

        // show counts
        countDiv.textContent = `Persons: ${data.count.persons}  â€”  Families: ${data.count.families}`;

        // enable TTL download (create a blob)
        dl.style.display = "inline";
        const ttl_blob = new Blob([data.ttl], { type: "text/turtle;charset=utf-8" });
        const ttl_url = URL.createObjectURL(ttl_blob);
        dl.href = ttl_url;
        dl.download = "output.ttl";
        dl.textContent = "Download TTL";

        // render graph from returned graph JSON
        renderGraph(data.graph.nodes, data.graph.links);

      } catch (err) {
        console.error(err);
        alert("Upload failed: " + err);
        status.textContent = "";
      }
    }

    function renderGraph(nodes, links) {
  // clear previous
  svg.selectAll("*").remove();

  const width = +svg.attr("width");
  const height = +svg.attr("height");

  // tooltip DOM element
  const tooltip = document.getElementById("tooltip");

  // ---- Zoom rect first (so it is below the node layer) ----
  // invisible rect captures zoom/pan gestures but lives under the container
  svg.append("rect")
    .attr("class", "zoom-rect")
    .attr("width", width)
    .attr("height", height)
    .style("fill", "transparent")
    .style("cursor", "move"); // shows move cursor on background

  // group that will be zoomed and must sit above the rect
  const container = svg.append("g").attr("class", "container");

  // convert link endpoints from ids to object refs
  const nodeById = new Map(nodes.map(d => [d.id, d]));
  links.forEach(l => {
    l.source = nodeById.get(l.source);
    l.target = nodeById.get(l.target);
  });

  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(90).strength(1))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", ticked);

  // draw links
  const link = container.append("g").attr("class", "links")
    .selectAll("line")
    .data(links)
    .enter().append("line")
    .attr("class", "link")
    .attr("stroke-width", 1.5)
    .attr("stroke", "#999")
    .attr("stroke-opacity", 0.6);

  // draw nodes
  const node = container.append("g").attr("class", "nodes")
    .selectAll("g")
    .data(nodes)
    .enter().append("g")
    .attr("class", d => `node ${d.type}`)
    .style("cursor", "pointer"); // show pointer on node hover

  node.append("circle")
    .attr("r", 8)
    .attr("stroke", "#333")
    .attr("stroke-width", 1.2);

  // Add an SVG <title> as a fallback (browser tooltip on hover)
  node.append("title").text(d => (d.label || d.id));

  // OPTIONAL: persistent labels (comment out if you want hover-only)
  // node.append("text")
  //   .attr("x", 12)
  //   .attr("y", 3)
  //   .attr("font-size", 11)
  //   .attr("fill", "#222")
  //   .text(d => (d.label || d.id).toString().split("/").pop())
  //   .style("pointer-events", "none");

  // Drag behavior (works with zoom)
  const drag = d3.drag()
    .on("start", (event, d) => {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      // freeze position
      d.fx = d.x;
      d.fy = d.y;
    })
    .on("drag", (event, d) => {
      // update fixed position (these are simulation coordinates)
      d.fx = event.x;
      d.fy = event.y;
    })
    .on("end", (event, d) => {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    });

  node.call(drag);

  // Hover interactions for HTML tooltip
  node.on("mouseover", (event, d) => {
    const text = (d.label || d.id).toString();
    tooltip.style.display = "block";
    tooltip.textContent = text;
    positionTooltip(event);
  }).on("mousemove", (event) => {
    positionTooltip(event);
  }).on("mouseout", () => {
    tooltip.style.display = "none";
  });

  function positionTooltip(event) {
    // keep tooltip near mouse; adjust offset so it doesn't overlap cursor
    const offsetX = 12;
    const offsetY = -12;
    tooltip.style.left = (event.pageX + offsetX) + "px";
    tooltip.style.top = (event.pageY + offsetY) + "px";
  }

  // zoom behavior: apply transforms to container (which is above the rect)
  const zoom = d3.zoom()
    .scaleExtent([0.1, 4])
    .on("zoom", (event) => {
      container.attr("transform", event.transform);
    });

  // attach zoom to svg (rect will still capture gestures but nodes receive mouse)
  svg.call(zoom);

  // tick update
  function ticked() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    node.attr("transform", d => `translate(${d.x},${d.y})`);
  }

  // kick simulation
  simulation.alpha(1).restart();
}

  </script>
</body>
</html>