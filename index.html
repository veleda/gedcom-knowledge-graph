<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>GEDCOM Knowledge Graph</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>

/* --- Page Layout --- */
body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  margin: 0;
  padding: 20px;
  background: #f7f9fc;
  color: #333;
}

h1 {
  text-align: center;
  color: #2c3e50;
  margin-bottom: 20px;
}

/* --- File Input and Buttons --- */
#gedcomFile {
  display: inline-block;
  margin-right: 10px;
  padding: 6px;
  border-radius: 4px;
  border: 1px solid #ccc;
}

button {
  padding: 6px 14px;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

button:hover {
  background-color: #2980b9;
}

#downloadLink {
  display: inline-block;
  margin-left: 10px;
  padding: 6px 14px;
  background-color: #2ecc71;
  color: white;
  text-decoration: none;
  border-radius: 4px;
  font-size: 14px;
  transition: background 0.2s;
}

#downloadLink:hover {
  background-color: #27ae60;
}

/* --- Count Info --- */
#count {
  margin-top: 10px;
  font-weight: 500;
  color: #555;
}

/* --- SVG Graph --- */
svg {
  border: 1px solid #ccc;
  background-color: #fff;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  border-radius: 6px;
  display: block;
  margin: 20px auto;
}

/* Node Styles */
.node circle {
  stroke: #333;
  stroke-width: 1.5px;
  cursor: pointer;
  transition: fill 0.2s, r 0.2s;
}

.node.person circle {
  fill: #3498db;
}

.node.family circle {
  fill: #e67e22;
}

.node:hover circle {
  stroke-width: 2.5px;
  r: 12px;
}

/* Links */
.link {
  stroke: #999;
  stroke-opacity: 0.6;
}

/* Labels */
text {
  font: 12px sans-serif;
  pointer-events: none;
  fill: #2c3e50;
  font-weight: 500;
}

 .tooltip {
    position: absolute;
    pointer-events: none;
    background: rgba(0,0,0,0.8);
    color: #fff;
    padding: 6px 8px;
    border-radius: 4px;
    font-size: 12px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    transform: translate(-50%, -120%); /* show above cursor */
    white-space: nowrap;
    z-index: 1000;
    display: none;
  }
  .zoom-rect {
    cursor: move;
    fill: none;
    pointer-events: all;
  }
/* Optional: Smooth transition for hover effect on nodes */
.node text {
  transition: fill 0.2s;
}


  </style>

</head>
<body>
  <h1>GEDCOM Knowledge Graph</h1>

  <div id="controls">
    <input type="file" id="gedcomFile">
    <button id="uploadBtn">Upload GEDCOM</button>
    <span id="status" style="margin-left:12px"></span>
    <div id="count"></div>
    <a id="dl" style="display:none">Download TTL</a>
  </div>

  <svg id="graph" width="1000" height="600"></svg>

  <script>
    const BACKEND_URL = "https://gedcom-knowledge-graph-backend.onrender.com";

    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("gedcomFile");
    const status = document.getElementById("status");
    const countDiv = document.getElementById("count");
    const dl = document.getElementById("dl");
    const svg = d3.select("#graph");

    uploadBtn.addEventListener("click", uploadGedcom);

    async function uploadGedcom() {
      status.textContent = "";
      if (!fileInput.files.length) {
        alert("Please choose a GEDCOM file first.");
        return;
      }
      const file = fileInput.files[0];
      const fd = new FormData();
      fd.append("file", file);

      try {
        status.textContent = "Uploading...";
        const resp = await fetch(`${BACKEND_URL}/parse`, { method: "POST", body: fd });

        if (!resp.ok) {
          const txt = await resp.text();
          alert("Upload failed: " + txt);
          status.textContent = "";
          return;
        }

        const data = await resp.json();
        status.textContent = "Done.";

        // show counts
        countDiv.textContent = `Persons: ${data.count.persons}  â€”  Families: ${data.count.families}`;

        // enable TTL download (create a blob)
        dl.style.display = "inline";
        const ttl_blob = new Blob([data.ttl], { type: "text/turtle;charset=utf-8" });
        const ttl_url = URL.createObjectURL(ttl_blob);
        dl.href = ttl_url;
        dl.download = "output.ttl";
        dl.textContent = "Download TTL";

        // render graph from returned graph JSON
        renderGraph(data.graph.nodes, data.graph.links);

      } catch (err) {
        console.error(err);
        alert("Upload failed: " + err);
        status.textContent = "";
      }
    }

    function renderGraph(nodes, links) {
      // clear previous
      svg.selectAll("*").remove();

      const width = +svg.attr("width");
      const height = +svg.attr("height");

      // tooltip DOM element
      const tooltip = document.getElementById("tooltip");

      // group that will be zoomed
      const container = svg.append("g").attr("class", "container");

      // add an invisible rect to capture zoom & pan events
      svg.append("rect")
        .attr("class", "zoom-rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "transparent");

      // convert link endpoints from ids to object refs
      const nodeById = new Map(nodes.map(d => [d.id, d]));
      links.forEach(l => {
        l.source = nodeById.get(l.source);
        l.target = nodeById.get(l.target);
      });

      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(90).strength(1))
        .force("charge", d3.forceManyBody().strength(-300))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .on("tick", ticked);

      // draw links
      const link = container.append("g").attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("class", "link")
        .attr("stroke-width", 1.5)
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6);

      // draw nodes
      const node = container.append("g").attr("class", "nodes")
        .selectAll("g")
        .data(nodes)
        .enter().append("g")
        .attr("class", d => `node ${d.type}`);

      node.append("circle")
        .attr("r", 8)
        .attr("stroke", "#333")
        .attr("stroke-width", 1.2);

      // small persistent label (optional). If you want labels only on hover, comment out this block.
      node.append("text")
        .attr("x", 12)
        .attr("y", 3)
        .attr("font-size", 11)
        .attr("fill", "#222")
        .text(d => (d.label || d.id).toString().split("/").pop())
        .style("pointer-events", "none"); // text shouldn't capture mouse

      // Drag behavior that works with zoom transform
      const drag = d3.drag()
        .on("start", (event, d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          // apply current transform to fx/fy coordinates
          const transform = d3.zoomTransform(svg.node());
          d.fx = transform.invertX(d.x);
          d.fy = transform.invertY(d.y);
        })
        .on("drag", (event, d) => {
          const transform = d3.zoomTransform(svg.node());
          // convert screen coords back into simulation coords
          d.fx = transform.invertX(event.x);
          d.fy = transform.invertY(event.y);
        })
        .on("end", (event, d) => {
          if (!event.active) simulation.alphaTarget(0);
          // keep node fixed where released, or set to null to allow free motion
          d.fx = null;
          d.fy = null;
        });

      node.call(drag);

      // Hover interactions for tooltip
      node.on("mouseover", (event, d) => {
        // show tooltip with full label or URI
        const text = (d.label || d.id).toString();
        tooltip.style.display = "block";
        tooltip.textContent = text;
        positionTooltip(event);
      }).on("mousemove", (event) => {
        positionTooltip(event);
      }).on("mouseout", () => {
        tooltip.style.display = "none";
      });

      function positionTooltip(event) {
        // position relative to page; adjust if needed
        const pad = 8;
        tooltip.style.left = (event.pageX) + "px";
        tooltip.style.top = (event.pageY - 10) + "px";
      }

      // zoom behavior
      const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", (event) => {
          container.attr("transform", event.transform);
        });

      svg.call(zoom);

      // tick update
      function ticked() {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        node.attr("transform", d => `translate(${d.x},${d.y})`);
      }

      // optional: fit/center graph on load (briefly restart alpha)
      simulation.alpha(1).restart();
    }

  </script>
</body>
</html>