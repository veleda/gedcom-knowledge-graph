<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>GEDCOM Knowledge Graph</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>

/* --- Page Layout --- */
body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  margin: 0;
  padding: 20px;
  background: #f7f9fc;
  color: #333;
}

h1 {
  text-align: center;
  color: #2c3e50;
  margin-bottom: 20px;
}

/* --- File Input and Buttons --- */
#gedcomFile {
  display: inline-block;
  margin-right: 10px;
  padding: 6px;
  border-radius: 4px;
  border: 1px solid #ccc;
}

button {
  padding: 6px 14px;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.2s;
}

button:hover {
  background-color: #2980b9;
}

#downloadLink {
  display: inline-block;
  margin-left: 10px;
  padding: 6px 14px;
  background-color: #2ecc71;
  color: white;
  text-decoration: none;
  border-radius: 4px;
  font-size: 14px;
  transition: background 0.2s;
}

#downloadLink:hover {
  background-color: #27ae60;
}

/* --- Count Info --- */
#count {
  margin-top: 10px;
  font-weight: 500;
  color: #555;
}

/* --- SVG Graph --- */
svg {
  border: 1px solid #ccc;
  background-color: #fff;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  border-radius: 6px;
  display: block;
  margin: 20px auto;
}

/* Node Styles */
.node circle {
  stroke: #333;
  stroke-width: 1.5px;
  cursor: pointer;
  transition: fill 0.2s, r 0.2s;
}

.node.person circle {
  fill: #3498db;
}

.node.family circle {
  fill: #e67e22;
}

.node:hover circle {
  stroke-width: 2.5px;
  r: 12px;
}

  /* rectangle node */
  .node-rect {
    fill: #69b3a2;         /* default node color (persons) */
    stroke: #333;
    stroke-width: 1.2px;
  }
  .node-family .node-rect { fill: #f39c12; } /* family color override */

  .node-initial {
    fill: white;
    font-weight: 700;
    font-family: sans-serif;
    pointer-events: none; /* let the group handle pointer events */
  }

/* Links */
.link {
  stroke: #999;
  stroke-opacity: 0.6;
}

/* Labels */
text {
  font: 12px sans-serif;
  pointer-events: none;
  fill: #2c3e50;
  font-weight: 500;
}

  /* tooltip */
  .tooltip {
    position: absolute;
    pointer-events: none;
    background: rgba(0,0,0,0.85);
    color: #fff;
    padding: 6px 8px;
    border-radius: 6px;
    font-size: 12px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    white-space: nowrap;
    display: none;
    z-index: 1000;
  }
  .zoom-rect {
    cursor: move;
    fill: none;
    pointer-events: all;
  }
/* Optional: Smooth transition for hover effect on nodes */
.node text {
  transition: fill 0.2s;
}


  </style>

</head>
<body>
  <h1>GEDCOM Knowledge Graph</h1>

  <div id="controls">
    <input type="file" id="gedcomFile">
    <button id="uploadBtn">Upload GEDCOM</button>
    <span id="status" style="margin-left:12px"></span>
    <div id="count"></div>
    <a id="dl" style="display:none">Download TTL</a>
  </div>

  <svg id="graph" width="1000" height="600"></svg>

  <script>
    const BACKEND_URL = "https://gedcom-knowledge-graph-backend.onrender.com";

    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("gedcomFile");
    const status = document.getElementById("status");
    const countDiv = document.getElementById("count");
    const dl = document.getElementById("dl");
    const svg = d3.select("#graph");

    uploadBtn.addEventListener("click", uploadGedcom);

    async function uploadGedcom() {
      status.textContent = "";
      if (!fileInput.files.length) {
        alert("Please choose a GEDCOM file first.");
        return;
      }
      const file = fileInput.files[0];
      const fd = new FormData();
      fd.append("file", file);

      try {
        status.textContent = "Uploading...";
        const resp = await fetch(`${BACKEND_URL}/parse`, { method: "POST", body: fd });

        if (!resp.ok) {
          const txt = await resp.text();
          alert("Upload failed: " + txt);
          status.textContent = "";
          return;
        }

        const data = await resp.json();
        status.textContent = "Done.";

        // show counts
        countDiv.textContent = `Persons: ${data.count.persons}  â€”  Families: ${data.count.families}`;

        // enable TTL download (create a blob)
        dl.style.display = "inline";
        const ttl_blob = new Blob([data.ttl], { type: "text/turtle;charset=utf-8" });
        const ttl_url = URL.createObjectURL(ttl_blob);
        dl.href = ttl_url;
        dl.download = "output.ttl";
        dl.textContent = "Download TTL";

        // render graph from returned graph JSON
        renderGraph(data.graph.nodes, data.graph.links);

      } catch (err) {
        console.error(err);
        alert("Upload failed: " + err);
        status.textContent = "";
      }
    }

function renderGraph(nodes, links) {
      // clear previous
      svg.selectAll("*").remove();

      const width = +svg.attr("width");
      const height = +svg.attr("height");

      // tooltip DOM element (HTML)
      const tooltip = document.getElementById("tooltip");

      // ---- Add zoom rect FIRST (under the container) ----
      svg.append("rect")
        .attr("class", "zoom-rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "transparent")
        .style("cursor", "move");

      // Group that will be transformed by zoom; sits above zoom-rect
      const container = svg.append("g").attr("class", "container");

      // Map ids -> node objects and fix link endpoints
      const nodeById = new Map(nodes.map(d => [d.id, d]));
      links.forEach(l => {
        l.source = nodeById.get(l.source);
        l.target = nodeById.get(l.target);
      });

      // Force simulation
      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(90).strength(1))
        .force("charge", d3.forceManyBody().strength(-300))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .on("tick", ticked);

      // Draw links
      const link = container.append("g").attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("class", "link")
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6)
        .attr("stroke-width", 1.2);

      // Helper: initials
      function initialsOf(label) {
        if (!label) return "";
        const words = label.toString().trim().split(/\s+/).filter(Boolean);
        if (words.length === 0) return "";
        if (words.length === 1) {
          return words[0].slice(0, 2).toUpperCase();
        }
        return (words[0][0] + (words[1] ? words[1][0] : "")).toUpperCase();
      }

      // Node groups
      const node = container.append("g").attr("class", "nodes")
        .selectAll("g")
        .data(nodes)
        .enter().append("g")
        .attr("class", d => `node ${d.type}`)
        .style("cursor", "pointer");

      // For each node: measure initials text, draw rect, draw initials text
      const paddingX = 8;
      const paddingY = 6;
      node.each(function(d) {
        const g = d3.select(this);
        const fullLabel = (d.label || d.id).toString();
        const init = initialsOf(fullLabel) || "";

        // Append a hidden measuring text to compute width/height
        const measuring = g.append("text")
          .attr("class", "node-initial measuring")
          .attr("font-size", 12)
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .style("visibility", "hidden")
          .text(init);

        // Force browser to compute layout, then measure
        // (getBBox works once node is in DOM)
        const bbox = measuring.node().getBBox();
        const w = bbox.width + paddingX * 2;
        const h = bbox.height + paddingY * 2;

        // remove measuring text
        measuring.remove();

        // append rounded rect centered on (0,0)
        g.append("rect")
          .attr("class", "node-rect")
          .attr("rx", Math.min(12, h / 2))
          .attr("ry", Math.min(12, h / 2))
          .attr("x", -w / 2)
          .attr("y", -h / 2)
          .attr("width", w)
          .attr("height", h);

        // initials text (visible)
        g.append("text")
          .attr("class", "node-initial")
          .attr("text-anchor", "middle")
          .attr("dominant-baseline", "middle")
          .attr("font-size", 12)
          .attr("fill", "white")
          .style("pointer-events", "none") // so dragging works on the group
          .text(init);
      });

      // Add <title> fallback tooltip
      node.append("title").text(d => (d.label || d.id));

      // DRAG behavior (works with zoom)
      const drag = d3.drag()
        .on("start", (event, d) => {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          // freeze simulation coords
          d.fx = d.x;
          d.fy = d.y;
        })
        .on("drag", (event, d) => {
          // event.x / event.y are in SVG coordinates (already transformed by zoom),
          // but because we apply transforms to container, d.x/d.y are simulation coords.
          // We keep it simple: update fx/fy with event coords translated back using inverse transform.
          const transform = d3.zoomTransform(svg.node());
          // convert screen coords to simulation coords by inverting current transform
          d.fx = transform.invertX(event.x);
          d.fy = transform.invertY(event.y);
        })
        .on("end", (event, d) => {
          if (!event.active) simulation.alphaTarget(0);
          // Release fixed position so nodes can move again
          d.fx = null;
          d.fy = null;
        });

      node.call(drag);

      // HTML tooltip interactions (hover)
      node.on("mouseover", (event, d) => {
        const text = (d.label || d.id).toString();
        if (tooltip) {
          tooltip.style.display = "block";
          tooltip.textContent = text;
          positionTooltip(event);
        }
      }).on("mousemove", (event) => {
        if (tooltip) positionTooltip(event);
      }).on("mouseout", () => {
        if (tooltip) tooltip.style.display = "none";
      });

      function positionTooltip(event) {
        const offsetX = 12;
        const offsetY = -12;
        tooltip.style.left = (event.pageX + offsetX) + "px";
        tooltip.style.top = (event.pageY + offsetY) + "px";
      }

      // Zoom behavior (apply transforms to container)
      const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", (event) => {
          container.attr("transform", event.transform);
        });

      svg.call(zoom);

      // Tick function: update positions
      function ticked() {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        node.attr("transform", d => `translate(${d.x},${d.y})`);
      }

      // Kick the simulation
      simulation.alpha(1).restart();
    }


  </script>
</body>
</html>